# 11 Debugging Optimized Code

----

Almost all compilers support optimization. With optimization disabled, the compiler generates assembly code that corresponds directly to your source code, in a simplistic way. As the compiler applies more powerful optimizations, the generated assembly code diverges from your original source code. With help from debugging information generated by the compiler, GDB can map from the running program back to constructs from your original source.

----

## 11.1 Inline Functions

Inlining is an optimization that inserts a copy of the function body directly at each call site, instead of jumping to a shared routine. GDB displays inlined functions just like non-inlined functions. They appear in _backtraces_. You can view their arguments and local variables, step into them with **step**, skip them with **next**, and escape from them with **finish**. You can check whether a function was inlined by using the **info frame** command.

For GDB to support inlined functions, the compiler must record information about inlining in the debug information â€” GCC using the DWARF 2 format does this, and several other compilers do also.

The body of an inlined function is directly included at its call site; unlike a non-inlined function, there are no instructions devoted to the call. GDB still pretends that the call site and the start of the inlined function are different instructions.

----

## 11.2 Tail Call Frames

Function _B_ can call function _C_ in its very last statement. In unoptimized compilation the call of _C_ is immediately followed by return instruction at the end of _B_ code. Optimizing compiler may replace the call and return in function _B_ into one jump to function _C_ instead. Such use of a jump instruction is called _tail call_.

During execution of function _C_, there will be no indication in the function call stack frames that it was tail-called from _B_. If function _A_ regularly calls function _B_ which tail-calls function _C_, then GDB will see _A_ as the caller of _C_.
